name: Commit Analysis

on:
  pull_request:
    branches: [main]

permissions:
  contents: read
  pull-requests: write

jobs:
  analyze:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze PR with LLM
        env:
          DEMETERICS_API_KEY: ${{ secrets.DEMETERICS_API_KEY }}
          REPO_NAME: ${{ github.event.repository.name }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          # Get PR info
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_AUTHOR="${{ github.event.pull_request.user.login }}"
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          # Get diff between base and head (limit to 500 lines)
          # Use || true to prevent SIGPIPE (exit 141) when head closes pipe early
          DIFF=$(git diff "$BASE_SHA"..."$HEAD_SHA" --no-color 2>/dev/null | head -500 || true)

          # Get list of changed files
          FILES_CHANGED=$(git diff "$BASE_SHA"..."$HEAD_SHA" --name-only 2>/dev/null | head -50 || true)

          echo "::group::PR Info"
          echo "Title: $PR_TITLE"
          echo "Author: $PR_AUTHOR"
          echo "Files changed: $(echo "$FILES_CHANGED" | wc -l)"
          echo "Diff lines: $(echo "$DIFF" | wc -l)"
          echo "::endgroup::"

          # Use jq to build valid JSON payload
          JSON_PAYLOAD=$(jq -n \
            --arg model "openai/gpt-oss-20b" \
            --arg repo "$REPO_NAME" \
            --arg author "$PR_AUTHOR" \
            --arg title "$PR_TITLE" \
            --arg files "$FILES_CHANGED" \
            --arg diff "$DIFF" \
            '{
              model: $model,
              messages: [
                {
                  role: "system",
                  content: ("/// APP: GitHub-Commit-Analysis\n/// FLOW: " + $repo + "\n/// USER: " + $author + "\n/// ENV: production\n\nYou are a code review assistant. Analyze this pull request and provide:\n1. Summary: Brief description of what changed\n2. Risk Assessment: Any potential bugs, issues, or breaking changes\n3. Security: Security considerations if applicable\n4. Suggestions: Improvements or best practices\n\nBe concise and actionable. Use markdown formatting.")
                },
                {
                  role: "user",
                  content: ("Analyze this pull request:\n\nTitle: " + $title + "\nAuthor: " + $author + "\n\nFiles changed:\n" + $files + "\n\nDiff:\n" + $diff)
                }
              ],
              temperature: 0.3,
              max_tokens: 2000
            }')

          # Call Demeterics API with verbose output
          echo "::group::API Call"
          HTTP_CODE=$(curl -s -o /tmp/response.json -w "%{http_code}" \
            https://api.demeterics.com/groq/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $DEMETERICS_API_KEY" \
            -d "$JSON_PAYLOAD")

          RESPONSE=$(cat /tmp/response.json)

          echo "HTTP Status: $HTTP_CODE"
          echo "Response keys: $(echo "$RESPONSE" | jq -r 'keys | join(", ")' 2>/dev/null || echo 'Not JSON')"
          echo "::endgroup::"

          # Check HTTP status
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::API returned HTTP $HTTP_CODE"
            echo "Response: ${RESPONSE:0:1000}"
            ANALYSIS="API Error: HTTP $HTTP_CODE - ${RESPONSE:0:200}"
          # Check for API error in response
          elif echo "$RESPONSE" | jq -e '.error' >/dev/null 2>&1; then
            ERROR_MSG=$(echo "$RESPONSE" | jq -r '.error.message // .error // "Unknown error"')
            echo "::error::LLM API error: $ERROR_MSG"
            ANALYSIS="API Error: $ERROR_MSG"
          else
            # Extract analysis from response
            # Some reasoning models (like gpt-oss-20b) put output in 'reasoning' field instead of 'content'
            ANALYSIS=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty')

            # If content is empty, try reasoning field
            if [ -z "$ANALYSIS" ]; then
              ANALYSIS=$(echo "$RESPONSE" | jq -r '.choices[0].message.reasoning // empty')
              if [ -n "$ANALYSIS" ]; then
                echo "::notice::Using reasoning field (model outputs there instead of content)"
              fi
            fi

            # Check if still empty after trying both fields
            if [ -z "$ANALYSIS" ]; then
              echo "::warning::Empty content in API response"
              FINISH_REASON=$(echo "$RESPONSE" | jq -r '.choices[0].finish_reason // "unknown"')
              echo "Finish reason: $FINISH_REASON"
              echo "Full response structure:"
              echo "$RESPONSE" | jq '.' 2>/dev/null || echo "$RESPONSE"
              ANALYSIS="Analysis unavailable - API returned empty content (finish_reason: $FINISH_REASON)"
            fi
          fi

          # Build comment body
          COMMENT_BODY=$(printf "## AI Code Review\n\n%s\n\n---\n*Powered by [Demeterics](https://demeterics.ai) with openai/gpt-oss-20b*" "$ANALYSIS")

          # Post comment to PR
          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"

          # Also output to Step Summary
          echo "$COMMENT_BODY" >> "$GITHUB_STEP_SUMMARY"
